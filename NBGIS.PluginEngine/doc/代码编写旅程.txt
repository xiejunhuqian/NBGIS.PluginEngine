作者：谢军
日期：2013-12-26

我对整个插件式框架学习的宏观的，梗概的，粗线条的描述为3个部分：打下深稳的根基，描绘出符合用户使用习惯的界面，打造灵活的插件
1 - 根基：宿主与插件的定义，分类，加载等部分，都是为了让他们交流，正常，良好，甚至是愉快的彼此倾述。
2 - 界面：
3 - 插件：


---------------------------------------------------------------------------------------------------------------


作者：谢军
日期：2013-12-20


系统中的对象行为介绍：

1 - 他们都是用来传递信息的（好比一根直线"----"）。不是用来在传递过程中进行任何形式的（加工，改造，创新的）逻辑判断。
IApplication - Application
IItemDef - ItemDef

2 - 他们都是用来在传递过程中进行任何形式的（加工，改造，创新的）逻辑判断（好比一根直线和逻辑行为符号"----+---*---/----"）。
ICommand
ITool


事件1：采用插件模式来开发软件之旅

第一步：这里是宿主对象对插件对象的自我介绍。
名称：宿主对象
包含：
			IApplication - 定义宿主对象的抽象结构
			Application  - 实现宿主对象的抽象结构


事件2：框架通信协议的设计

背景介绍：
宿主与插件之间的关系我目前所知道的有2种：
1 - 表现在UI级别上，宿主是个容器，是个父窗口，插件是元素，是个按钮、工具条等。
2 - 表现在功能级别上，插件分2中类型：
			2-1 命令，如按钮按下后插件开始活动；
			2-2 依赖，外部触发，键盘，鼠标。

AcrMap 中产生一个Tool对象，需要同时实现ICommand和ITool两个接口，
		其中ICommand定义启动Tool交互过程的方法；
		而ITool定义人机交互时候需要的所有方法；

这里我们把上面2部分放在一个ITool里面。


第二步：这里是 ICommand 和 ITool 插件对象
名称： ICommand 和 ITool 插件对象
包含：
		AcrMap 中产生一个Tool对象，需要同时实现ICommand和ITool两个接口，
		其中ICommand定义启动Tool交互过程的方法；
		而ITool定义人机交互时候需要的所有方法；


第三步：介绍两种纯粹的UI类型插件对象，及其组成他们的元素Item
名称： IToolBarDef（工具条） 和 IMenuDef（菜单栏） 插件对象 和 Item（项）对象
包含：
			他们是一个容器，一个面板，他们本身没有任何的事件和方法，只是一种用于按放 ICommand 和 ITool 的UI对象。

			Item 是他们的组成元素，是设计他们的前提。
				他有唯一的id，用来标示自己区别其他元素；
				他的位置，可能在组，可能在子组。


事件3：通信契约设计小结

类结构：
				IPlugin
					|
				ICommand、ITool、IDockableWindow、IToolBarDef、IMenuDef

小结：
			至此，我们已经设计好了所有的通信契约，这些契约都是接口，没有任何实现。
			这使得，宿主与插件处于一种松散耦合的状态，不论插件对象的实现代码如何改变，只要他们实现了契约，都将被框架的宿主程序
			视为插件。

			只要插件改为契约要求的积木，就可以用来在称为世界的宿主中使用。
			插件-契约-宿主
			积木-契约-世界



---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2013-12-23


事件1：插件式应用框架中宿主程序运行时候，插件在处于什么状态？

关键词：选择容器，创建容器

插件与动态链接库
			动态链接库：只有在大家需要的时候才会载入内存中，供大家使用。
					   插件：在大家需要之前，他们早已经由插件引擎（把积木打包运送到世界的某个角落，就等着大家来发现，使用他们了）
	动态的生成了不同的插件对象，并放置在一个容器中随时等候被使用。


容器
		用来装东西的包包，箱子一样的东西。东西不一样，包包也会不一样。
关系
		IEnumerable
			|
		ICollection、IDictionary、IList
			|					|					|
		Queue			Hashtable		Array
		Stack			SortedList		ArrayList
		LinkList		DicitonaryList	List
			|					|					|	
(小巧，灵活，极快，生活在内存中)
								|					|
(字典，索引，硕大，灵活，多变，一对一对的生活在一起)
													|
(有序、无序，灵活，生活在扁平空间中)

		他们，好像生活在一栋栋可以随意移动的大楼里。
		他们，有的楼层小，一般安置在急速生活区；
				   有的楼层高，给每个房间编辑了号码，房间和号码一一对应，找人，移动也快；
				   有的楼层中，一般安置在中速生活区；

使用CollectionBase等抽象类来生成自定义的容器，集合
		CollectionBase、ReadOnlyCollectionBase、DicitionaryBase 他们就是生成强容器类型的工具。
		CollectionBase 实现了 IList、ICollection、IEnumerable 等3个接口。大家可以根据自己的需要
来使用。

泛型机制
		他们是容器，但是这个容器在使用之前，就已经表明哪些对象可以进入，哪些对象不能进入。
降低了容器与对象之间的转化过程(装箱、拆箱的转化过程)。

聚合方法来产生容器
		把工具尽量的分解成小而有点智慧的东西，然后根据工作需要组合，聚合他们。
		工具集 = a、b.....x、y
		?001 = a + x
		?002 = b + y

		不要，少用继承来制作工具，多用去除中心化的面向对象思想来制作愚笨而有点智慧的小东西。


关键词：读访问、使用容器元素

		PluginCollectionEnumeratro.cs	他是一个迭代器，用来从容器中以直线方式把元素取出。

关键词：写访问、修改容器元素


关键词：插件的动态加载和对象生成

		PluginHandle.cs 它是用来动态加载程序集和根据程序集包含的类型信息生成对象。
		根据用户发出的请求，然后从宿主-插件架构中生成对象。


---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2013-12-24


事件1：框架日志处理

关键词：问题，出现，记录，分析，学习，解决，工具，Log4net

简述Log4net：

关键词：它的组成部分，（实例及其讲解部分，去看书 U2-P75-80）

Root 是日志文件内所有的需要日志管理的对象列表
Logger 是Root的子类
Appender 是需要日志管理的对象
Layout 是需要日志管理的对象的内容格式，布局
Repository 是库（这个还不了解它的存在意义，估计是一个装载Logger的容器吧？）

Logger 负责产生日志消息，他提供很多方法来实现这一使命。一个程序中可以有多个，每个都单独对待。
Appender 为 Logger 定义了日志输出的目的地，可以把日志内容放入文件，数据库，电子邮件什么的。
Layout 设置了日志信息的形式，输出格式。
Repository 这里没用到，不做说明。



事件2：插件的类型

关键词：类型的转换和判别，is 和 as

c#是强类型的语言
		这意味着，一个对象在c#中不应该似是而非，除非出现不得已的情况，请不要轻易的将一个对象装箱为 object，
否则，频繁的 boxing、unboxing 工作将会降低性能。

is 和 as
		
		例子1：is
		if( objA is objB )
		{
			objB = (objB) objA;
		}
		这个过程中，objA被强制转化为objB，而返回的只是判断结果，是/否。如果是，强化转化还要再来一次。
		简化来看这个过程，1次强制转化，返回逻辑结果，又1次强制转化。

		例子2：as
		string s = objS as string
		if( s != null)
		{
			Console.WriteLine(" ' " + s + " ' ");
		}
		这个过程中，objS强制转化为string，成功返回一个s，不成功返回一个null。
		简化来看这个过程，1次强制转化，返回结果，成功返回一个s，不成功返回一个null。

		原则：避免不必须要的强制转化。
		结论：基于这个原则，我们应该采用 as 来做 对象间是否兼容的检查。
		理解：没有一定好与坏，及时有，我们也找不到，分辨不出来，但是我们能找到，分辨出是否合适做这个事情，或者
是否不合适做那件事情。


事件3：插件分类的设计与实现

关键词：ParsePluginCollection.cs，插件容器，分类，插件，存入不同类别的泛型容器中
从插件容器中取出插件，分类存放到适合的容器中。


---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2013-12-25

事件1：小结以上事件。

关键词：插件引擎库、宿主、插件、容器、分类

	1.	插件引擎库的设计与实现。
		
		包括3个部分：
		
			1-1.契约设计（用接口来定义NBGIS的插件对象类型，他们都继承IPlugin接口。）
				他们是：
					ICommand
					ITool
					IMenuDef
					IToolBarDef
					IDockableWindowDef
					IApplication（为了宿主程序的信息能够传递给插件对象，宿主与插件的交流。）
					IItemDef、ItemDef（为了正确描述菜单栏和工具条的组成项。）

			1-2.插件容器的设计（我们把插件分类后，放入指定的容器中。）
				他们是：
					PluginCollection
					PluginCollectionEnumerator
					我们介绍了使用 CollectionBase 抽象类和通过聚合方式、泛型类生产插件容器的方法；从容器中遍历插件的方法
					（IEnumerator 对象和 foreach 方法）；

			1-3.插件的动态加载和插件分类
				他们是：
					PluginHandle
					ParsePluginCollection
					我们实用了 .NET的反射机制，他能根据一个插件类型的描述信息，来加载，实例化插件对象。
					期间，为了避免运行错误，使用了异常机制和日志记录（log4net.dll）。
					我们根据1-1中的插件内容，产生了各种类型的插件容器，分门别类的来装载插件对象。

							
		
---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2013-12-26

事件1：建立宿主窗体，在它上面放置各类插件来装扮宿主窗体。

关键词：宿主窗体，插件，装扮

1 - 添加 Janus组件库
	本地地址：C:\Program Files\Janus Systems\Controls for Microsoft .NET\Windows Forms Controls v3\Bin
	添加方法：工具箱 - .Net firework - 选择进入本地地址选择 Janus.Windows.UI.v3.dll 即可。他会把库中的
	所有组件都加载的。
	下载地址：csdn（下载完毕后，记得去点评，这样会把分还给我。而且自己也要时常上去看看，上传资料，
	拿积分，下载资料，点评，扣积分，换积分。）


2 - 宿主程序中插件大管家
	宿主程序中插件动态生成的菜单和工具条都由它来统一管理。UICommandManager控件


事件2：AriGIS Engine 9.3 的安装程序，安装说明，破解工具，破解说明，博客园，紫微星，迅雷下载？

结果：已解决

解决过程：

关键词：thirdPlugin、安装及其破解方法文档

1 - thirdPlugin
		里装着的第三方控件，和AriGIS提供给大家开发的控件。

2 - 安装及其破解方法文档
		http://wenku.baidu.com/link?url=5EFU6eOE17q4l7tOggIPsEPul3HqnATL44mCZxyXC9o_a-77Gs3sFh3QI3pZkYj1akpNOv-jr9AWtRjO3l6BYH0d-_zA7QR3921yWZvl81W

---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2013-12-27

事件1：继续 建立宿主窗体，在它上面放置各类插件来装扮宿主窗体。

1 - ArcGIS Engine中初始化许可常见问题归纳
		http://blog.sina.com.cn/s/blog_4ad115cb010009bi.html



---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2013-12-28

事件1：继续 建立宿主窗体，在它上面放置各类插件来装扮宿主窗体。

关键词：用Janus搭建、分割、划分、标注各个插件的位置，然后放入插件，至此宿主窗体
静态部分完毕，接下来逐步完成各个插件的功能，插件之间的连接、通讯等。

1 - 不同的插件在宿主窗体上将以什么样的UI形式出现呢？
		IMenuDef 是菜单栏中的一个菜单
		IToolBarDef 是一个工具条
		ITool、ICommand 
				相同之处：看起来是相同的命令按钮
				差异之处：
						ITool 需要跟其他对象交互之后才能完整的表达，描述自己和他人（接力赛、汽车零件等
				需要多人交互，多零件组合的多对象交互活动）；
						ICommand 自己独立完整的表达，描述自己	（单人长跑、马拉松、环岛自行车等，
				对象的单独活动）
		IItemDef
				它作为 ITool、ICommand 住所、栖息地 安置在 IMenuDef、IToolBarDef（某个小区）里的 IItemDef （某个房间）中


2 - 破解 Janus组件库


---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2013-12-31

事件1：插件UI对象

关键词：分布类（Partial Class）、类、结构、接口、定义、拆分、源文件、组合、一个文件

1 - MainGIS类，插件UI对象所有的代码都会在这个分布类里完成，实现。
		分布类，把类、结构、接口的定义拆分到两个或者多个源文件中。每个源文件只包含类定义的一部分，
		编译的应用程序的时候后将把所有部分组合起来，就好像他们是一个文件。

2 - 加载和解析插件
		是在MainGIS的Load方法中完成的，该方法将在宿主程序窗口加载时被触发，在这个方法中加载所有的
		插件对象，然后根据插件对象各自的UI对象并将其适当的事件绑定。
		插件 - 加载 - UI对象 - 事件 - 绑定。

3 - 宿主程序 MainGIS 负责：加载、调用插件对象
		具体来说分2部分：
				将插件对象以UI方式在窗体上显示。
				将插件对象与宿主控件的事件进行绑定。
				这2部分都需要定义合适的公共变量进行初始化，都是在宿主程序 MainGIS 类中实现。



---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2014-01-04

事件1：把值类型 改成 引用种类，把宿主与插件之间的对话，从通过中间人带话给彼此，改为面对面的直接对话。

关键词：值类型，引用类型，中间人，面对面


事件2：插件获取

关键词：GetPluginArray，不同的类型插件，分类，装入，不同类型的插件集合，取出插件集合开始使用。
		ICommand对象、ITool对象、IMenuDef对象、IToolBarDef对象和 IDockableWindowDef对象。


---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2014-01-06

事件1：插件与框架的关系

关键词：
	
	插件：
	它的相貌、摸样：可视化界面，UI层对象（命令按钮、工具条、菜单栏等）。
	它的举止、行为：通过委托方式将事件对象与插件联系起来。
	
	理解：
	在插件式应用框架中，其功能的扩展，添加，删除都是由插件对象来实现的。
	可是，插件对象，
	（插件对象，整体框架，显示层，人，都市，相貌）
	起初，是没有可视化界面的，那我们就需要用一种方式给插件对象一副相貌，保证它在大都市的存在。
	（插件对象，整体框架，行为层，逻辑层，人，都市，灵魂，技能）
	然后，是没有生命，和灵魂，这是我们就又需要给予它灵魂好让它能学习到这样或者那样的技能，好让它能在大都市中生存，活下来。

	解析、ICommand 和 ITool:
	（有躯体，有灵魂）（插件，框架，显示，事件，人，都市，摸样，灵魂，技能，生存，活下去）

	解析、IMenuDef 和 IToolBarDef:
	（只有躯体，没有灵魂）（插件，框架，显示，雕塑，都市，摸样）


	C:\windows\assembly\GAC_MSIL\ESRI.ArcGIS.SystemUI\9.3.0.1770__8fc3cc631e44ad86\ESRI.ArcGIS.SystemUI.dll


	C:\Windows\Microsoft.NET\Framework\v2.0.50727\System.Drawing.dll


---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2014-01-09

事件1：制作插件，建立 插件对象 与 UI对象 之间的联系

关键词：初始化主框架（创建插件，建立 插件对象 与 UI对象 之间的联系）

	把我们之前做的工作整理组合下：
		1 - 宿主、插件的定义，实现，关系。
		2 - 容器，用来分类装载插件。
		3 - 主界面，初始化主框架（建立 插件对象 与 UI对象 之间的联系）。
			采用的分布模式，把接口，类，委托代理，通过关系组合起来，构成一幅美丽的画面。这，正式我想要的。


---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2014-01-10

事件1：继续创建不同类型的插件后，把他们放入到主框架体中。

关键词：（创建，连接，激活）的细节。

事件2：寻找问题？的解决方法之路。
		
		乱七八糟的构思，

		思想实现的过程
		= 问题具体，抽象的过程 
		= 顺着模糊的脉络找到分界点，
		= 对分割后的对象进行逐步的由粗到细的层层切分，
		= 一边找，一边算，一边实践，就会找到分界点之间的联系，
		= 对联系后的对象集合进行具体-抽象的转化，
		= 期望得到一个相对稳定的结果。

		寻找标尺一般的工具，方法，思想来度量，计算，转化，数字化，实践，验证，揭示，构思：
			这个过程中反反复复的重复着，计算着每个阶段的，关键的构思，并尝试着组合，拆分他们，并与现实中的事件，物体
		相比对，期望能找到相似点，来验证自己的方法是否有效，这样的活动直至得到一个与自己思想相互融合的抽象对象为止，
		这个活动是循环往复，无休无止。
		
			如果得到了，就会把成果采用文字记录下来，融入于心，而每每遇到问题就随心所用而解。
		
			如果没得到，就会放下，过段时间遇到问题了，再来尝试解决。


---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2014-01-14

事件1：为什么其他的控件没有加载上来呢？只有DockableWindowsDef被加载了呢？

解答1：
	关键词：【项目】、【类】、【方法】
	具体内容：
		NBGIS.PluginEngine：【项目】
		 - PluginHandle.cs：【类】他负责使用反射机制把插件对象，装入指定类型的包包中。
			- GetPluginsFromDll()：【方法】他实现了【类】。查看这里的代码，就可以找到不同插件对象被放入不同包包的代码片段。



---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2014-02-10

事件1：小结

关键词：插件对象、插件式框架、枝叶、扩展、根干、基础、开发人员

具体内容：

第一部分：插件对象、插件式框架、开发人员之间的关系
	插件对象 是 插件式框架的扩展功能的、根干的枝叶的 具体实现者；
	他们一般表现为一个具体的插件类，他们实现了插件框架的功能，并符合插件框架的契约；
	开发人员在编写插件对象的时候，是不需要熟悉框架宿主程序的运行机制的；

第二部分：插件引擎、宿主程序的关系；具体的插件编写；
	
	远看（宏观规划xx蓝图）：插件引擎和宿主程序的开发需要大处着眼、细处着手、不断迭代设计才能实现；

	近看（微观建设xx蓝图）：具体插件的编写就让扩展开发人员从这个大局跳出来，他们只需要深入一偶，实现具体的功能即可；

	隔离（隔离宏观规划与微观建设）：插件开发者与通信协议隔离开来，降低了插件的开发难度，降低了开发人员的学习曲线，更重要的是，宿主程序的代码的安全性得到了保障；

第三部分：
	ArcGIS Engine 9.2 为了简化开发人员的工作而内置几种非常有用的组件：就是一些功能对象，工具对象，提供给我们使用；
	
	插件设计内容：已经实现了 ICommand、ITool、IToolBarDef、IDockableWindowDef等4中插件对象的代码；
	
	目前的插件式GIS应用框架（a已经实现了，下面继续b的设计与实现）：（第一步|a）比较稳定了，但是不实用。（第二步|b）下面我们将在宿主程序的外延和内涵上进行讨论，在其上实现更多的功能和枝叶。
	

---------------------------------------------------------------------------------------------------------------

作者：谢军
日期：2014-02-10	

Chapter 5

关键词：宿主程序的高级设计